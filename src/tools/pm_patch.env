#!/usr/bin/env bash
# 
# Copyright (c) 2013, Lucien XU <sfietkonstantin@free.fr>
# Copyright (c) 2016, Andrey Kozhevnikov <coderusinbox@gmail.com>
# Copyright (c) 2021, Patchmanger for SailfishOS contributors:
#                     - olf "Olf0" <https://github.com/Olf0>
#                     - Peter G. "nephros" <sailfish@nephros.org>
#                     - Vlad G. "b100dian" <https://github.com/b100dian>
# Copyright (c) 2023, Patchmanger for SailfishOS contributors:
#                     - Roberto A. Foglietta <roberto.foglietta@gmail.com>   
#
# Licensed like the orginal code under BSD 3-Clause License
#
###############################################################################

set -o pipefail

action=$1; shift

#
# Some constants
#

# Root
ROOT_DIR="/tmp/patchmanager"
PM_VAR_DIR="/tmp/patchmanager3"
PATCH_ROOT_DIR="/usr/share/patchmanager/patches"

# Applications
PATCH_EXEC="/usr/bin/patch"

# Paths / Files
PARAMETER="$1"
PATCH_DIR="$PATCH_ROOT_DIR/$1"

PM_LOG_FILE="$PM_VAR_DIR/patchmanager.log"
PM_PATCH_BACKUP_ROOT_DIR="$PM_VAR_DIR/patches"
PM_PATCH_BACKUP_DIR="$PM_PATCH_BACKUP_ROOT_DIR/$1"

SYS_BITNESS=$(/usr/bin/getconf LONG_BIT)

# Constants
PATCH_NAME="unified_diff.patch"
PATCH_PATH="$PATCH_DIR/$PATCH_NAME"
PATCH_EDITED_NAME="unified_diff_${SYS_BITNESS}bit.patch"

#
# Here starts the part where all the magic happens
#

log() {
  echo -e "$@" | tee -a "$PM_LOG_FILE"
}

logbar() {
  log "------------------------------------"
}

failure() {
  log
  log "############## FAILED ##############"
  log
  sync
  exit 1
}

success() {
  log
  log "************* SUCCESS **************"
  log
  sync
  exit 0
}

if [ "$action" = "unapply" ]; then
  PATCH_BACKUP="$PM_PATCH_BACKUP_DIR/$PATCH_NAME"
  PATCH_EDITED_BACKUP="$PM_PATCH_BACKUP_DIR"/"$PATCH_EDITED_NAME"
  if [ -f "$PATCH_EDITED_BACKUP" ]; then
    PATCH_FILE="$PATCH_EDITED_BACKUP"
  elif [ -f "$PATCH_BACKUP" ]; then
    PATCH_FILE="$PATCH_BACKUP"
  else
    PATCH_FILE="$PATCH_PATH"
  fi
elif [ "$action" = "apply" ]; then
  # list of candidate paths to attempt 32-/64-bit library path correction
  MANGLE_CANDIDATES=""
  if [ -z "$DISABLE_MANGLING" ] && [ -r "/etc/patchmanager/manglelist.conf" ] ; then
    source /etc/patchmanager/manglelist.conf
  fi
  PATCH_FILE="$PATCH_PATH"
  mkdir -p "$PM_VAR_DIR" > /dev/null 2>&1
else
  log "ERROR: action = '$action' not recognised"
  failure
fi

#
# Helper functions that do all the heavy work needed
#

test_if_applied() {
  test -f "$PATCH_FILE" || return 1
  log
  logbar
  log "Test if already applied patch"
  logbar 
  log
  $PATCH_EXEC -R -p 1 -d "$ROOT_DIR" --dry-run < "$PATCH_FILE" 2>&1 | tee -a "$PM_LOG_FILE"
}

remove_text_patch() {
  test -f "$PATCH_FILE" || return 1
  log
  logbar
  log "Reverting (unapplying) applied patch file"
  logbar
  log

  $PATCH_EXEC -R -p 1 -d "$ROOT_DIR" --no-backup-if-mismatch < "$PATCH_FILE" 2>&1 | tee -a "$PM_LOG_FILE"
  if [ $? -eq 0 ]; then
    success
  fi
}

clean_backup_patch() {
  log
  logbar
  log "Deleting backup of patch file"
  logbar
  log
  rm -rf "$PM_PATCH_BACKUP_DIR" >/dev/null 2>&1
  log "Removed backup: $PM_PATCH_BACKUP_DIR"
  log
}

# For details see issue #71: https://github.com/sailfishos-patches/patchmanager/issues/71
mangle_libpath() {
  test -f "$PATCH_FILE" || return 1
    log
    logbar
  [ $SYS_BITNESS -eq 32 ] && log "Checking paths for 32-bit --> 64-bit conversion"
  [ $SYS_BITNESS -eq 64 ] && log "Checking paths for 64-bit --> 32-bit conversion"
  elif [ $SYS_BITNESS -eq 64 ]; then
    log

  candidates="$MANGLE_CANDIDATES"
  if [ $SYS_BITNESS -eq 32 ]; then
    # first, convert the candidate list
    # variable expansion ${foo/lib/lib64} would work on bash, but not POSIX sh or busybox's ash
    candidates=$(printf '%s' "$MANGLE_CANDIDATES" | sed 's@/usr/lib/@/usr/lib64/@g')
  fi
  log "Mangle candidates: $candidates"
  log

  found=0
  sedcmd=""
  # look for lines to convert, if some are found add pattern to sed scriptlet
  for p in $candidates; do
    cand_lines=$(grep -c "^+++ [^/]*$p" "$PATCH_FILE")
    if [ $cand_lines -eq 0 ]; then
      continue  # nothing found, try next
    fi
    found=$(( $found + $cand_lines ))
    log "Converting library path reference $p $cand_lines times"

    # prepare the path replacement pattern
    pr=""
    if [ $SYS_BITNESS -eq 32 ]; then
      pr=$(printf '%s' "$p" | sed 's@/usr/lib64/@/usr/lib/@')
    elif [ $SYS_BITNESS -eq 64 ]; then
      pr=$(printf '%s' "$p" | sed 's@/usr/lib/@/usr/lib64/@')
    else
      failure
    fi
    # append at the front so ';' can be easily used for separation 
    sedcmd="s@^+++ \([^/]*\)$p@+++ \1$pr@g;s@^--- \([^/]*\)$p@--- \1$pr@g;$sedcmd"
  done

  if [ $found -eq 0 ]; then
    log
    log "OK, found nothing to convert."
    log
  else
    mkdir -p "$PM_PATCH_BACKUP_DIR"
    patch_edited_path="$PM_PATCH_BACKUP_DIR"/"$PATCH_EDITED_NAME"

    # create mangled patch file and add a note to it
    printf '#\n# Patch converted to %sbit library paths from its original by Patchmanager > 3.1\n# Date: %s\n#\n' $SYS_BITNESS $(date -Iseconds) \
    | cat - "$PATCH_FILE" | sed "$sedcmd" > "$patch_edited_path"  # patch the Patch
    if [ $? -ne 0 ]; then
      failure
    fi
    
    log
    log "OK, converted $found library path references and created: $patch_edited_path"
    log
    # set the patch path to the new one:
    PATCH_FILE="$patch_edited_path"
  fi
}

verify_text_patch() {
  test -f "$PATCH_FILE" || return 1
  log
  logbar
  log "Dry running patch file"
  logbar
  log

  $PATCH_EXEC -p 1 -d "$ROOT_DIR" --dry-run < "$PATCH_FILE" 2>&1 | tee -a "$PM_LOG_FILE"
  if [ $? -ne 0 ]; then
    failure
  fi
}

install_text_patch() {
  test -f "$PATCH_FILE" || return 1
  log
  logbar
  log "Applying patch file"
  logbar
  log

  $PATCH_EXEC -p 1 -d "$ROOT_DIR" --no-backup-if-mismatch < "$PATCH_FILE" 2>&1 | tee -a "$PM_LOG_FILE"
  if [ $? -eq 0 ]; then
    success
  fi
}

create_backup_patch() {
  log
  logbar
  log "Creating backup of patch file"
  logbar
  log

  mkdir -p "$PM_PATCH_BACKUP_DIR" >/dev/null 2>&1
  # Backup the original patch file, NOT $PATCH_FILE, which might be altered by 32-/64-bit mangling in line 143.
  # If mangling was performed successfully, it already wrote its patched $PATCH_EDITED_NAME to $PM_PATCH_BACKUP_DIR in line 134.
  cp -f "$PATCH_DIR/$PATCH_NAME" "$PM_PATCH_BACKUP_DIR" >/dev/null 2>&1
  log "Created backup: $PM_PATCH_BACKUP_DIR"
  log
}

#
# Bunch of safety checks and required initializations
#

  if [ ! -f "$PM_LOG_FILE" ]; then
  log "*** Patch-log created by pm_$action script $(date -Iseconds) ***"
  fi
  log
  logbar
log "pm_$action $(date -Iseconds)"
  logbar
  log

  sync

  if [ -z "$PARAMETER" ]; then
  log "ERROR: A parameter must be provided for the pm_$action script!"
    failure
  fi

  if [ ! -d "$PATCH_DIR" ]; then
    log "ERROR: $PATCH_DIR is not a directory or does not exist!"
    failure
  fi

log "$(basename "$PATCH_DIR")"
  log

  if [ ! -x "$PATCH_EXEC" ]; then
    log "ERROR: Cannot use patch executable ${PATCH_EXEC}!"
    failure
  fi

log "Using patch file: $PATCH_FILE"

  if [ ! -f "$PATCH_FILE" ]; then
    log "ERROR: Cannot find patch file!"
    failure
  fi

#
# The main function that controls all the magic stuff
#

if [ "$action" = "apply" ]; then
  [ -n "$MANGLE_CANDIDATES" ] && mangle_libpath
  test_if_applied && success
  verify_text_patch
  install_text_patch
  create_backup_patch
else
  test_if_applied
  remove_text_patch
  clean_backup_patch
fi

success

exit 0
